<!doctype html>
<html >
<head>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!--[if lt IE 9]>
                <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
        <![endif]-->
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

  <meta http-equiv="Content-Style-Type" content="text/css" />

  <link rel="stylesheet" type="text/css" href="/template.css" />

  <link href="https://vjs.zencdn.net/5.4.4/video-js.css" rel="stylesheet" />



<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script type='text/javascript' src='/menu/js/jquery.cookie.js'></script>
<script type='text/javascript' src='/menu/js/jquery.hoverIntent.minified.js'></script>
<script type='text/javascript' src='/menu/js/jquery.dcjqaccordion.2.7.min.js'></script>

<link href="/menu/css/skins/blue.css" rel="stylesheet" type="text/css" />
<link href="/menu/css/skins/graphite.css" rel="stylesheet" type="text/css" />
<link href="/menu/css/skins/grey.css" rel="stylesheet" type="text/css" />
  
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
  
  <script src="/script.js"></script>
  
    <script src="/jquery.sticky-kit.js "></script>
  <meta name="generator" content="pandoc" />
  <title>QMK Firmware</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
</head>
<body>

    
  <div class="navbar navbar-static-top">
    <div class="navbar-inner">
      <div class="container">
        <span class="doc-title"><a href="/">QMK Firmware</a> / <a href="/keyboard/">keyboards</a></span>
        <ul class="nav pull-right doc-info">
          <li><p class="navbar-text"><a href="http://github.com/jackhumbert/qmk_firmware">View on Github</a></p></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="container">
    <div class="row">
            <div id="TOC" class="span4">

            
        <div class="well toc">

        <ul>
        <li><a href="#quantum-mechanical-keyboard-firmware">Quantum Mechanical Keyboard Firmware</a><ul>
        <li><a href="#documentation-roadmap">Documentation roadmap</a></li>
        <li><a href="#getting-started">Getting started</a><ul>
        <li><a href="#makefile-options">Makefile Options</a></li>
        <li><a href="#customizing-makefile-options-on-a-per-keymap-basis">Customizing Makefile options on a per-keymap basis</a></li>
        <li><a href="#customizing-config.h-on-a-per-keymap-basis">Customizing config.h on a per-keymap basis</a></li>
        </ul></li>
        <li><a href="#quick-aliases-to-common-actions">Quick aliases to common actions</a><ul>
        <li><a href="#switching-and-toggling-layers">Switching and toggling layers</a></li>
        <li><a href="#fun-with-modifier-keys">Fun with modifier keys</a></li>
        <li><a href="#space-cadet-shift-the-future-built-in">Space Cadet Shift: The future, built in</a></li>
        <li><a href="#the-leader-key-a-new-kind-of-modifier">The Leader key: A new kind of modifier</a></li>
        <li><a href="#temporarily-setting-the-default-layer">Temporarily setting the default layer</a></li>
        <li><a href="#prevent-stuck-modifiers">Prevent stuck modifiers</a></li>
        <li><a href="#remember-these-are-just-aliases">Remember: These are just aliases</a></li>
        </ul></li>
        <li><a href="#macro-shortcuts-send-a-whole-string-when-pressing-just-one-key">Macro shortcuts: Send a whole string when pressing just one key</a><ul>
        <li><a href="#advanced-macro-functions">Advanced macro functions</a></li>
        </ul></li>
        <li><a href="#additional-keycode-aliases-for-software-implemented-layouts-colemak-dvorak-etc">Additional keycode aliases for software-implemented layouts (Colemak, Dvorak, etc)</a></li>
        <li><a href="#additional-language-support">Additional language support</a></li>
        <li><a href="#unicode-support">Unicode support</a></li>
        <li><a href="#other-firmware-shortcut-keycodes">Other firmware shortcut keycodes</a></li>
        <li><a href="#driving-a-speaker---audio-support">Driving a speaker - audio support</a></li>
        <li><a href="#midi-functionalty">MIDI functionalty</a></li>
        <li><a href="#bluetooth-functionality">Bluetooth functionality</a></li>
        <li><a href="#international-characters-on-windows">International Characters on Windows</a></li>
        <li><a href="#rgb-under-glow-mod">RGB Under Glow Mod</a><ul>
        <li><a href="#ws2812-wiring">WS2812 Wiring</a></li>
        </ul></li>
        <li><a href="#safety-considerations">Safety Considerations</a></li>
        </ul></li>
        </ul>

        </div>


            

      
            

      </div>
            <div class="span8">
            <h1 id="quantum-mechanical-keyboard-firmware"><a href="#quantum-mechanical-keyboard-firmware">Quantum Mechanical Keyboard Firmware</a></h1>
<p><a href="https://travis-ci.org/jackhumbert/qmk_firmware"><embed src="https://travis-ci.org/jackhumbert/qmk_firmware.svg?branch=master" /></a></p>
<p>This is a keyboard firmware based on the <a href="http://github.com/tmk/tmk_keyboard">tmk_keyboard firmware</a> with some useful features for Atmel AVR controllers, and more specifically, the <a href="http://olkb.co">OLKB product line</a>, the <a href="http://www.ergodox-ez.com">ErgoDox EZ</a> keyboard, and the <a href="http://clueboard.co/">Clueboard product line</a>.</p>
<p>QMK is developed and maintained by Jack Humbert of OLKB with contributions from the community, and of course, TMK. In fact, this repo used to be a fork of TMK, and we are incredibly grateful for his founding contributions to the firmware. We've had to break the fork due to purely technical reasons -- it simply became too different over time, and we've had to start refactoring some of the basic bits and pieces. We are huge fans of TMK, both the firmware and the person. :)</p>
<p>This documentation is edited and maintained by Erez Zukerman of ErgoDox EZ. If you spot any typos or inaccuracies, please <a href="https://github.com/jackhumbert/qmk_firmware/issues/new">open an issue</a>.</p>
<p>The OLKB product firmwares are maintained by Jack, the Ergodox EZ by Erez, and the Clueboard by <a href="https://github.com/skullydazed">Zach White</a>.</p>
<h2 id="documentation-roadmap"><a href="#documentation-roadmap">Documentation roadmap</a></h2>
<p>This is not a tiny project. While this is the main Readme, there are many other files you might want to consult. Here are some points of interest:</p>
<ul>
<li>The Readme for your own keyboard: This is found under <code>keyboards/&lt;your keyboards's name&gt;/</code>. So for the ErgoDox EZ, it's <a href="keyboards/ergodox_ez/">here</a>; for the Atomic, it's <a href="keyboards/atomic/">here</a> and so on.<br /></li>
<li>The <a href="doc/BUILD_GUIDE.md">build guide</a>, also mentioned in the next section. This is how you put your development environment together so you can compile the firmware.<br /></li>
<li>The list of possible keycodes you can use in your keymap is actually spread out in a few different places:<br /></li>
<li><a href="tmk_core/common/keycode.h">tmk_core/common/keycode.h</a> - the base TMK keycodes. This is the actual source file.<br /></li>
<li><a href="doc/keycode.txt">doc/keycode.txt</a> - an explanation of those same keycodes.<br /></li>
<li><a href="quantum/keymap_common.h">quantum/keymap_common.h</a> - this is where the QMK-specific aliases are all set up. Things like the Hyper and Meh key, the Leader key, and all of the other QMK innovations. These are also explained and documented below, but <code>keymap_common.h</code> is where they're actually defined.<br /></li>
<li>The <a href="doc/TMK_README.md">TMK documentation</a>. QMK is based on TMK, and this explains how it works internally.</li>
</ul>
<h2 id="getting-started"><a href="#getting-started">Getting started</a></h2>
<ul>
<li><a href="doc/BUILD_GUIDE.md">BUILD_GUIDE.md</a> contains instructions to set up a build environment, build the firmware, and deploy it to a keyboard. Once your build environment has been set up, all <code>make</code> commands to actually build the firmware must be run from a folder in <code>keyboards/</code>.<br /></li>
<li>If you're looking to customize a keyboard that currently runs QMK or TMK, find your keyboard's directory under <code>keyboards/</code> and run the make commands from there.<br /></li>
<li>If you're looking to apply this firmware to an entirely new hardware project (a new kind of keyboard), you can create your own Quantum-based project by using <code>util/new_project.sh &lt;project_name&gt;</code>, which will create <code>/keyboards/&lt;project_name&gt;</code> with all the necessary components for a Quantum project.</li>
</ul>
<h3 id="makefile-options"><a href="#makefile-options">Makefile Options</a></h3>
<p>You have access to a bunch of goodies! Check out the Makefile to enable/disable some of the features. Uncomment the <code>#</code> to enable them. Setting them to <code>no</code> does nothing and will only confuse future you.</p>
<pre><code>BACKLIGHT_ENABLE = yes # Enable keyboard backlight functionality
MIDI_ENABLE = yes      # MIDI controls
UNICODE_ENABLE = no    # &lt;-- This is how you disable an option, just set it to &quot;no&quot;
BLUETOOTH_ENABLE = yes # Enable Bluetooth with the Adafruit EZ-Key HID</code></pre>
<h3 id="customizing-makefile-options-on-a-per-keymap-basis"><a href="#customizing-makefile-options-on-a-per-keymap-basis">Customizing Makefile options on a per-keymap basis</a></h3>
<p>If your keymap directory has a file called <code>Makefile</code> (note the filename), any Makefile options you set in that file will take precedence over other Makefile options (those set for Quantum as a whole or for your particular keyboard).</p>
<p>So let's say your keyboard's makefile has <code>CONSOLE_ENABLE = yes</code> (or maybe doesn't even list the <code>CONSOLE_ENABLE</code> option, which would cause it to revert to the global Quantum default). You want your particular keymap to not have the debug console, so you make a file called <code>Makefile</code> and specify <code>CONSOLE_ENABLE = no</code>.</p>
<h3 id="customizing-config.h-on-a-per-keymap-basis"><a href="#customizing-config.h-on-a-per-keymap-basis">Customizing config.h on a per-keymap basis</a></h3>
<p>You can also make a <code>config.h</code> file in your keymap directory and use it to override any <code>config.h</code> settings you don't like. Anything you set there will take precedence over the global <code>config.h</code> for the ErgoDox EZ. To see an example of this, check out <code>keymaps/erez_experimental</code>.</p>
<h2 id="quick-aliases-to-common-actions"><a href="#quick-aliases-to-common-actions">Quick aliases to common actions</a></h2>
<p>Your keymap can include shortcuts to common operations (called &quot;function actions&quot; in tmk).</p>
<h3 id="switching-and-toggling-layers"><a href="#switching-and-toggling-layers">Switching and toggling layers</a></h3>
<p><code>MO(layer)</code> - momentary switch to <em>layer</em>. As soon as you let go of the key, the layer is deactivated and you pop back out to the previous layer. When you apply this to a key, that same key must be set as <code>KC_TRNS</code> on the destination layer. Otherwise, you won't make it back to the original layer when you release the key (and you'll get a keycode sent). You can only switch to layers <em>above</em> your current layer. If you're on layer 0 and you use <code>MO(1)</code>, that will switch to layer 1 just fine. But if you include <code>MO(3)</code> on layer 5, that won't do anything for you -- because layer 3 is lower than layer 5 on the stack.</p>
<p><code>OSL(layer)</code> - momentary switch to <em>layer</em>, as a one-shot operation. So if you have a key that's defined as <code>OSL(1)</code>, and you tap that key, then only the very next keystroke would come from layer 1. You would drop back to layer zero immediately after that one keystroke. That's handy if you have a layer full of custom shortcuts -- for example, a dedicated key for closing a window. So you tap your one-shot layer mod, then tap that magic 'close window' key, and keep typing like a boss. Layer 1 would remain active as long as you hold that key down, too (so you can use it like a momentary toggle-layer key with extra powers).</p>
<p><code>LT(layer, kc)</code> - momentary switch to <em>layer</em> when held, and <em>kc</em> when tapped. Like <code>MO()</code>, this only works upwards in the layer stack (<code>layer</code> must be higher than the current layer).</p>
<p><code>TG(layer)</code> - toggles a layer on or off. As with <code>MO()</code>, you should set this key as <code>KC_TRNS</code> in the destination layer so that tapping it again actually toggles back to the original layer. Only works upwards in the layer stack.</p>
<h3 id="fun-with-modifier-keys"><a href="#fun-with-modifier-keys">Fun with modifier keys</a></h3>
<ul>
<li><code>LSFT(kc)</code> - applies left Shift to <em>kc</em> (keycode) - <code>S(kc)</code> is an alias<br /></li>
<li><code>RSFT(kc)</code> - applies right Shift to <em>kc</em><br /></li>
<li><code>LCTL(kc)</code> - applies left Control to <em>kc</em><br /></li>
<li><code>RCTL(kc)</code> - applies right Control to <em>kc</em><br /></li>
<li><code>LALT(kc)</code> - applies left Alt to <em>kc</em><br /></li>
<li><code>RALT(kc)</code> - applies right Alt to <em>kc</em><br /></li>
<li><code>LGUI(kc)</code> - applies left GUI (command/win) to <em>kc</em><br /></li>
<li><code>RGUI(kc)</code> - applies right GUI (command/win) to <em>kc</em><br /></li>
<li><code>HYPR(kc)</code> - applies Hyper (all modifiers) to <em>kc</em><br /></li>
<li><code>MEH(kc)</code> - applies Meh (all modifiers except Win/Cmd) to <em>kc</em><br /></li>
<li><code>LCAG(kc)</code> - applies CtrlAltGui to <em>kc</em></li>
</ul>
<p>You can also chain these, like this:</p>
<pre><code>LALT(LCTL(KC_DEL)) -- this makes a key that sends Alt, Control, and Delete in a single keypress.</code></pre>
<p>The following shortcuts automatically add <code>LSFT()</code> to keycodes to get commonly used symbols. Their long names are also available and documented in <code>/quantum/keymap_common.h</code>.</p>
<pre><code>KC_TILD  ~
KC_EXLM  !
KC_AT    @
KC_HASH  #
KC_DLR   $
KC_PERC  %
KC_CIRC  ^
KC_AMPR  &amp;
KC_ASTR  *
KC_LPRN  (
KC_RPRN  )
KC_UNDS  _
KC_PLUS  +
KC_DQUO  &quot;
KC_LCBR  {
KC_RCBR  }
KC_LABK  &lt;
KC_RABK  &gt;
KC_PIPE  |
KC_COLN  :</code></pre>
<p><code>OSM(mod)</code> - this is a &quot;one shot&quot; modifier. So let's say you have your left Shift key defined as <code>OSM(MOD_LSFT)</code>. Tap it, let go, and Shift is &quot;on&quot; -- but only for the next character you'll type. So to write &quot;The&quot;, you don't need to hold down Shift -- you tap it, tap t, and move on with life. And if you hold down the left Shift key, it just works as a left Shift key, as you would expect (so you could type THE). There's also a magical, secret way to &quot;lock&quot; a modifier by tapping it multiple times. If you want to learn more about that, open an issue. :)</p>
<p><code>MT(mod, kc)</code> - is <em>mod</em> (modifier key - MOD_LCTL, MOD_LSFT) when held, and <em>kc</em> when tapped. In other words, you can have a key that sends Esc (or the letter O or whatever) when you tap it, but works as a Control key or a Shift key when you hold it down.</p>
<p>These are the values you can use for the <code>mod</code> in <code>MT()</code> and <code>OSM()</code> (right-hand modifiers are not available for <code>MT()</code>):</p>
<ul>
<li>MOD_LCTL<br /></li>
<li>MOD_LSFT<br /></li>
<li>MOD_LALT<br /></li>
<li>MOD_LGUI<br /></li>
<li>MOD_HYPR<br /></li>
<li>MOD_MEH</li>
</ul>
<p>These can also be combined like <code>MOD_LCTL | MOD_LSFT</code> e.g. <code>MT(MOD_LCTL | MOD_LSFT, KC_ESC)</code> which would activate Control and Shift when held, and send Escape when tapped.</p>
<p>We've added shortcuts to make common modifier/tap (mod-tap) mappings more compact:</p>
<ul>
<li><code>CTL_T(kc)</code> - is LCTL when held and <em>kc</em> when tapped<br /></li>
<li><code>SFT_T(kc)</code> - is LSFT when held and <em>kc</em> when tapped<br /></li>
<li><code>ALT_T(kc)</code> - is LALT when held and <em>kc</em> when tapped<br /></li>
<li><code>GUI_T(kc)</code> - is LGUI when held and <em>kc</em> when tapped<br /></li>
<li><code>ALL_T(kc)</code> - is Hyper (all mods) when held and <em>kc</em> when tapped. To read more about what you can do with a Hyper key, see <a href="http://brettterpstra.com/2012/12/08/a-useful-caps-lock-key/">this blog post by Brett Terpstra</a><br /></li>
<li><code>LCAG_T(kc)</code> - is CtrlAltGui when held and <em>kc</em> when tapped<br /></li>
<li><code>MEH_T(kc)</code> - is like Hyper, but not as cool -- does not include the Cmd/Win key, so just sends Alt+Ctrl+Shift.</li>
</ul>
<h3 id="space-cadet-shift-the-future-built-in"><a href="#space-cadet-shift-the-future-built-in">Space Cadet Shift: The future, built in</a></h3>
<p>Steve Losh <a href="http://stevelosh.com/blog/2012/10/a-modern-space-cadet/">described</a> the Space Cadet Shift quite well. Essentially, you hit the left Shift on its own, and you get an opening parenthesis; hit the right Shift on its own, and you get the closing one. When hit with other keys, the Shift key keeps working as it always does. Yes, it's as cool as it sounds.</p>
<p>To use it, use <code>KC_LSPO</code> (Left Shift, Parens Open) for your left Shift on your keymap, and <code>KC_RSPC</code> (Right Shift, Parens Close) for your right Shift.</p>
<p>It's defaulted to work on US keyboards, but if your layout uses different keys for parenthesis, you can define those in your <code>config.h</code> like this:</p>
<pre><code>#define LSPO_KEY KC_9
#define RSPC_KEY KC_0</code></pre>
<p>The only other thing you're going to want to do is create a <code>Makefile</code> in your keymap directory and set the following:</p>
<pre><code>COMMAND_ENABLE   = no  # Commands for debug and configuration</code></pre>
<p>This is just to keep the keyboard from going into command mode when you hold both Shift keys at the same time.</p>
<h3 id="the-leader-key-a-new-kind-of-modifier"><a href="#the-leader-key-a-new-kind-of-modifier">The Leader key: A new kind of modifier</a></h3>
<p>If you've ever used Vim, you know what a Leader key is. If not, you're about to discover a wonderful concept. :) Instead of hitting Alt+Shift+W for example (holding down three keys at the same time), what if you could hit a <em>sequence</em> of keys instead? So you'd hit our special modifier (the Leader key), followed by W and then C (just a rapid succession of keys), and something would happen.</p>
<p>That's what <code>KC_LEAD</code> does. Here's an example:</p>
<ol>
<li>Pick a key on your keyboard you want to use as the Leader key. Assign it the keycode <code>KC_LEAD</code>. This key would be dedicated just for this -- it's a single action key, can't be used for anything else.<br /></li>
<li>Include the line <code>#define LEADER_TIMEOUT 300</code> somewhere in your keymap.c file, probably near the top. The 300 there is 300ms -- that's how long you have for the sequence of keys following the leader. You can tweak this value for comfort, of course.<br /></li>
<li>Within your <code>matrix_scan_user</code> function, do something like this:</li>
</ol>
<pre><code>void matrix_scan_user(void) {
  LEADER_DICTIONARY() {
    leading = false;
    leader_end();

    SEQ_ONE_KEY(KC_F) {
      register_code(KC_S);
      unregister_code(KC_S);
    }
    SEQ_TWO_KEYS(KC_A, KC_S) {
      register_code(KC_H);
      unregister_code(KC_H);
    }
    SEQ_THREE_KEYS(KC_A, KC_S, KC_D) {
      register_code(KC_LGUI);
      register_code(KC_S);
      unregister_code(KC_S);
      unregister_code(KC_LGUI);
    }
  }
}</code></pre>
<p>As you can see, you have three function. you can use - <code>SEQ_ONE_KEY</code> for single-key sequences (Leader followed by just one key), and <code>SEQ_TWO_KEYS</code> and <code>SEQ_THREE_KEYS</code> for longer sequences. Each of these accepts one or more keycodes as arguments. This is an important point: You can use keycodes from <strong>any layer on your keyboard</strong>. That layer would need to be active for the leader macro to fire, obviously.</p>
<h3 id="temporarily-setting-the-default-layer"><a href="#temporarily-setting-the-default-layer">Temporarily setting the default layer</a></h3>
<p><code>DF(layer)</code> - sets default layer to <em>layer</em>. The default layer is the one at the &quot;bottom&quot; of the layer stack - the ultimate fallback layer. This currently does not persist over power loss. When you plug the keyboard back in, layer 0 will always be the default. It is theoretically possible to work around that, but that's not what <code>DF</code> does.</p>
<h3 id="prevent-stuck-modifiers"><a href="#prevent-stuck-modifiers">Prevent stuck modifiers</a></h3>
<p>Consider the following scenario:</p>
<ol>
<li>Layer 0 has a key defined as Shift.<br /></li>
<li>The same key is defined on layer 1 as the letter A.<br /></li>
<li>User presses Shift.<br /></li>
<li>User switches to layer 1 for whatever reason.<br /></li>
<li>User releases Shift, or rather the letter A.<br /></li>
<li>User switches back to layer 0.</li>
</ol>
<p>Shift was actually never released and is still considered pressed.</p>
<p>If such situation bothers you add this to your <code>config.h</code>:</p>
<pre><code>#define PREVENT_STUCK_MODIFIERS</code></pre>
<p>This option uses 5 bytes of memory per every 8 keys on the keyboard<br />rounded up (5 bits per key). For example on Planck (48 keys) it uses<br />(48/8)*5 = 30 bytes.</p>
<h3 id="remember-these-are-just-aliases"><a href="#remember-these-are-just-aliases">Remember: These are just aliases</a></h3>
<p>These functions work the same way that their <code>ACTION_*</code> functions do - they're just quick aliases. To dig into all of the tmk ACTION_* functions, please see the <a href="https://github.com/jackhumbert/qmk_firmware/blob/master/doc/keymap.md#2-action">TMK documentation</a>.</p>
<p>Instead of using <code>FNx</code> when defining <code>ACTION_*</code> functions, you can use <code>F(x)</code> - the benefit here is being able to use more than 32 function actions (up to 4096), if you happen to need them.</p>
<h2 id="macro-shortcuts-send-a-whole-string-when-pressing-just-one-key"><a href="#macro-shortcuts-send-a-whole-string-when-pressing-just-one-key">Macro shortcuts: Send a whole string when pressing just one key</a></h2>
<p>Instead of using the <code>ACTION_MACRO</code> function, you can simply use <code>M(n)</code> to access macro <em>n</em> - <em>n</em> will get passed into the <code>action_get_macro</code> as the <code>id</code>, and you can use a switch statement to trigger it. This gets called on the keydown and keyup, so you'll need to use an if statement testing <code>record-&gt;event.pressed</code> (see keymap_default.c).</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">const</span> macro_t *action_get_macro(keyrecord_t *record, <span class="dt">uint8_t</span> id, <span class="dt">uint8_t</span> opt) <span class="co">// this is the function signature -- just copy/paste it into your keymap file as it is.</span>
{
  <span class="kw">switch</span>(id) {
    <span class="kw">case</span> <span class="dv">0</span>: <span class="co">// this would trigger when you hit a key mapped as M(0)</span>
      <span class="kw">if</span> (record-&gt;event.pressed) {
        <span class="kw">return</span> MACRO( I(<span class="dv">255</span>), T(H), T(E), T(L), T(L), W(<span class="dv">255</span>), T(O), END  ); <span class="co">// this sends the string &#39;hello&#39; when the macro executes</span>
      }
      <span class="kw">break</span>;
  }
  <span class="kw">return</span> MACRO_NONE;
};</code></pre>
<p>A macro can include the following commands:</p>
<ul>
<li>I() change interval of stroke in milliseconds.<br /></li>
<li>D() press key.<br /></li>
<li>U() release key.<br /></li>
<li>T() type key(press and release).<br /></li>
<li>W() wait (milliseconds).<br /></li>
<li>END end mark.</li>
</ul>
<p>So above you can see the stroke interval changed to 255ms between each keystroke, then a bunch of keys being typed, waits a while, then the macro ends.</p>
<p>Note: Using macros to have your keyboard send passwords for you is possible, but a bad idea.</p>
<h3 id="advanced-macro-functions"><a href="#advanced-macro-functions">Advanced macro functions</a></h3>
<p>To get more control over the keys/actions your keyboard takes, the following functions are available to you in the <code>action_get_macro</code> function block:</p>
<ul>
<li><code>record-&gt;event.pressed</code></li>
</ul>
<p>This is a boolean value that can be tested to see if the switch is being pressed or released. An example of this is</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">if</span> (record-&gt;event.pressed) {
  <span class="co">// on keydown</span>
} <span class="kw">else</span> {
  <span class="co">// on keyup</span>
}</code></pre>
<ul>
<li><code>register_code(&lt;kc&gt;);</code></li>
</ul>
<p>This sends the <code>&lt;kc&gt;</code> keydown event to the computer. Some examples would be <code>KC_ESC</code>, <code>KC_C</code>, <code>KC_4</code>, and even modifiers such as <code>KC_LSFT</code> and <code>KC_LGUI</code>.</p>
<ul>
<li><code>unregister_code(&lt;kc&gt;);</code></li>
</ul>
<p>Parallel to <code>register_code</code> function, this sends the <code>&lt;kc&gt;</code> keyup event to the computer. If you don't use this, the key will be held down until it's sent.</p>
<ul>
<li><code>layer_on(&lt;n&gt;);</code></li>
</ul>
<p>This will turn on the layer <code>&lt;n&gt;</code> - the higher layer number will always take priority. Make sure you have <code>KC_TRNS</code> for the key you're pressing on the layer you're switching to, or you'll get stick there unless you have another plan.</p>
<ul>
<li><code>layer_off(&lt;n&gt;);</code></li>
</ul>
<p>This will turn off the layer <code>&lt;n&gt;</code>.</p>
<ul>
<li><code>clear_keyboard();</code></li>
</ul>
<p>This will clear all mods and keys currently pressed.</p>
<ul>
<li><code>clear_mods();</code></li>
</ul>
<p>This will clear all mods currently pressed.</p>
<ul>
<li><code>clear_keyboard_but_mods();</code></li>
</ul>
<p>This will clear all keys besides the mods currently pressed.</p>
<ul>
<li><code>update_tri_layer(layer_1, layer_2, layer_3);</code></li>
</ul>
<p>If the user attempts to activate layer 1 AND layer 2 at the same time (for example, by hitting their respective layer keys), layer 3 will be activated. Layers 1 and 2 will <em>also</em> be activated, for the purposes of fallbacks (so a given key will fall back from 3 to 2, to 1 -- and only then to 0).</p>
<h4 id="naming-your-macros"><a href="#naming-your-macros">Naming your macros</a></h4>
<p>If you have a bunch of macros you want to refer to from your keymap, while keeping the keymap easily readable, you can just name them like so:</p>
<pre><code>#define AUD_OFF M(6)
#define AUD_ON M(7)
#define MUS_OFF M(8)
#define MUS_ON M(9)
#define VC_IN M(10)
#define VC_DE M(11)
#define PLOVER M(12)
#define EXT_PLV M(13)</code></pre>
<p>As was done on the <a href="/keyboards/planck/keymaps/default/keymap.c#L33-L40">Planck default keymap</a></p>
<h4 id="timer-functionality"><a href="#timer-functionality">Timer functionality</a></h4>
<p>It's possible to start timers and read values for time-specific events - here's an example:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">uint16_t</span> key_timer;
key_timer = timer_read();
<span class="kw">if</span> (timer_elapsed(key_timer) &lt; <span class="dv">100</span>) {
  <span class="co">// do something if less than 100ms have passed</span>
} <span class="kw">else</span> {
  <span class="co">// do something if 100ms or more have passed</span>
}</code></pre>
<p>It's best to declare the <code>static uint16_t key_timer;</code> outside of the macro block (top of file, etc).</p>
<h4 id="example-single-key-copypaste-hold-to-copy-tap-to-paste"><a href="#example-single-key-copypaste-hold-to-copy-tap-to-paste">Example: Single-key copy/paste (hold to copy, tap to paste)</a></h4>
<p>With QMK, it's easy to make one key do two things, as long as one of those things is being a modifier. :) So if you want a key to act as Ctrl when held and send the letter R when tapped, that's easy: <code>CTL_T(KC_R)</code>. But what do you do when you want that key to send Ctrl-V (paste) when tapped, and Ctrl-C (copy) when held?</p>
<p>Here's what you do:</p>
<pre><code>static uint16_t key_timer;

const macro_t *action_get_macro(keyrecord_t *record, uint8_t id, uint8_t opt)
{
      switch(id) {
        case 0: {
            if (record-&gt;event.pressed) {
                key_timer = timer_read(); // if the key is being pressed, we start the timer.
            }
            else { // this means the key was just released, so we can figure out how long it was pressed for (tap or &quot;held down&quot;).
                if (timer_elapsed(key_timer) &gt; 150) { // 150 being 150ms, the threshhold we pick for counting something as a tap.
                    return MACRO( D(LCTL), T(C), U(LCTL), END  );
                }
                else {
                    return MACRO( D(LCTL), T(V), U(LCTL), END  );
                }
            }
            break;
        }
      }
    return MACRO_NONE;
};</code></pre>
<p>And then, to assign this macro to a key on your keyboard layout, you just use <code>M(0)</code> on the key you want to press for copy/paste.</p>
<h2 id="additional-keycode-aliases-for-software-implemented-layouts-colemak-dvorak-etc"><a href="#additional-keycode-aliases-for-software-implemented-layouts-colemak-dvorak-etc">Additional keycode aliases for software-implemented layouts (Colemak, Dvorak, etc)</a></h2>
<p>Everything is assuming you're in Qwerty (in software) by default, but there is built-in support for using a Colemak or Dvorak layout by including this at the top of your keymap:</p>
<p>#include <keymap_colemak.h></p>
<p>If you use Dvorak, use <code>keymap_dvorak.h</code> instead of <code>keymap_colemak.h</code> for this line. After including this line, you will get access to:</p>
<ul>
<li><code>CM_*</code> for all of the Colemak-equivalent characters<br /></li>
<li><code>DV_*</code> for all of the Dvorak-equivalent characters</li>
</ul>
<p>These implementations assume you're using Colemak or Dvorak on your OS, not on your keyboard - this is referred to as a software-implemented layout. If your computer is in Qwerty and your keymap is in Colemak or Dvorak, this is referred to as a firmware-implemented layout, and you won't need these features.</p>
<p>To give an example, if you're using software-implemented Colemak, and want to get an <code>F</code>, you would use <code>CM_F</code> - <code>KC_F</code> under these same circumstances would result in <code>T</code>.</p>
<h2 id="additional-language-support"><a href="#additional-language-support">Additional language support</a></h2>
<p>In <code>quantum/keymap_extras/</code>, you'll see various language files - these work the same way as the alternative layout ones do. Most are defined by their two letter country/language code followed by an underscore and a 4-letter abbreviation of its name. <code>FR_UGRV</code> which will result in a <code>ù</code> when using a software-implemented AZERTY layout. It's currently difficult to send such characters in just the firmware (but it's being worked on - see Unicode support).</p>
<h2 id="unicode-support"><a href="#unicode-support">Unicode support</a></h2>
<p>You can currently send 4 hex digits with your OS-specific modifier key (RALT for OSX with the &quot;Unicode Hex Input&quot; layout) - this is currently limited to supporting one OS at a time, and requires a recompile for switching. 8 digit hex codes are being worked on. The keycode function is <code>UC(n)</code>, where <em>n</em> is a 4 digit hexidecimal. Enable from the Makefile.</p>
<h2 id="other-firmware-shortcut-keycodes"><a href="#other-firmware-shortcut-keycodes">Other firmware shortcut keycodes</a></h2>
<ul>
<li><code>RESET</code> - puts the MCU in DFU mode for flashing new firmware (with <code>make dfu</code>)<br /></li>
<li><code>DEBUG</code> - the firmware into debug mode - you'll need hid_listen to see things<br /></li>
<li><code>BL_ON</code> - turns the backlight on<br /></li>
<li><code>BL_OFF</code> - turns the backlight off<br /></li>
<li><code>BL_&lt;n&gt;</code> - sets the backlight to level <em>n</em><br /></li>
<li><code>BL_INC</code> - increments the backlight level by one<br /></li>
<li><code>BL_DEC</code> - decrements the backlight level by one<br /></li>
<li><code>BL_TOGG</code> - toggles the backlight<br /></li>
<li><code>BL_STEP</code> - steps through the backlight levels</li>
</ul>
<p>Enable the backlight from the Makefile.</p>
<h2 id="driving-a-speaker---audio-support"><a href="#driving-a-speaker---audio-support">Driving a speaker - audio support</a></h2>
<p>Your keyboard can make sounds! If you've got a Planck, Preonic, or basically any keyboard that allows access to the C6 port, you can hook up a simple speaker and have it beep. You can use those beeps to indicate layer transitions, modifiers, special keys, or just to play some funky 8bit tunes.</p>
<p>The audio code lives in <a href="/quantum/audio/audio.h">quantum/audio/audio.h</a> and in the other files in the audio directory. It's enabled by default on the Planck <a href="/keyboards/planck/keymaps/default/keymap.c">stock keymap</a>. Here are the important bits:</p>
<pre><code>#include &quot;audio.h&quot;</code></pre>
<p>Then, lower down the file:</p>
<pre><code>float tone_startup[][2] = {
    ED_NOTE(_E7 ),
    E__NOTE(_CS7),
    E__NOTE(_E6 ),
    E__NOTE(_A6 ),
    M__NOTE(_CS7, 20)
};</code></pre>
<p>This is how you write a song. Each of these lines is a note, so we have a little ditty composed of five notes here.</p>
<p>Then, we have this chunk:</p>
<pre><code>float tone_qwerty[][2]     = SONG(QWERTY_SOUND);
float tone_dvorak[][2]     = SONG(DVORAK_SOUND);
float tone_colemak[][2]    = SONG(COLEMAK_SOUND);
float tone_plover[][2]     = SONG(PLOVER_SOUND);
float tone_plover_gb[][2]  = SONG(PLOVER_GOODBYE_SOUND);

float music_scale[][2] = SONG(MUSIC_SCALE_SOUND);
float goodbye[][2] = SONG(GOODBYE_SOUND);</code></pre>
<p>Wherein we bind predefined songs (from <a href="/audio/song_list.h">audio/song_list.h</a>) into named variables. This is one optimization that helps save on memory: These songs only take up memory when you reference them in your keymap, because they're essentially all preprocessor directives.</p>
<p>So now you have something called <code>tone_plover</code> for example. How do you make it play the Plover tune, then? If you look further down the keymap, you'll see this:</p>
<pre><code>PLAY_NOTE_ARRAY(tone_plover, false, 0); // Signature is: Song name, repeat, rest style</code></pre>
<p>This is inside one of the macros. So when that macro executes, your keyboard plays that particular chime.</p>
<p>&quot;Rest style&quot; in the method signature above (the last parameter) specifies if there's a rest (a moment of silence) between the notes.</p>
<h2 id="midi-functionalty"><a href="#midi-functionalty">MIDI functionalty</a></h2>
<p>This is still a WIP, but check out <code>quantum/keymap_midi.c</code> to see what's happening. Enable from the Makefile.</p>
<h2 id="bluetooth-functionality"><a href="#bluetooth-functionality">Bluetooth functionality</a></h2>
<p>This requires <a href="https://www.reddit.com/r/MechanicalKeyboards/comments/3psx0q/the_planck_keyboard_with_bluetooth_guide_and/?ref=search_posts">some hardware changes</a>, but can be enabled via the Makefile. The firmware will still output characters via USB, so be aware of this when charging via a computer. It would make sense to have a switch on the Bluefruit to turn it off at will.</p>
<h2 id="international-characters-on-windows"><a href="#international-characters-on-windows">International Characters on Windows</a></h2>
<p><a href="https://autohotkey.com">AutoHotkey</a> allows Windows users to create custom hotkeys among others.</p>
<p>The method does not require Unicode support in the keyboard itself but depends instead of AutoHotkey running in the background.</p>
<p>First you need to select a modifier combination that is not in use by any of your programs.<br />CtrlAltWin is not used very widely and should therefore be perfect for this.<br />There is a macro defined for a mod-tab combo <code>LCAG_T</code>.<br />Add this mod-tab combo to a key on your keyboard, e.g.: <code>LCAG_T(KC_TAB)</code>.<br />This makes the key behave like a tab key if pressed and released immediately but changes it to the modifier if used with another key.</p>
<p>In the default script of AutoHotkey you can define custom hotkeys.</p>
<pre><code>&lt;^&lt;!&lt;#a::Send, ä
&lt;^&lt;!&lt;#&lt;+a::Send, Ä</code></pre>
<p>The hotkeys above are for the combination CtrlAltGui and CtrlAltGuiShift plus the letter a.<br />AutoHotkey inserts the Text right of <code>Send,</code> when this combination is pressed.</p>
<h2 id="rgb-under-glow-mod"><a href="#rgb-under-glow-mod">RGB Under Glow Mod</a></h2>
<p><img src="https://raw.githubusercontent.com/yangliu/qmk_firmware/planck-rgb/keyboards/planck/keymaps/yang/planck-with-rgb-underglow.jpg" alt="Planck with RGB Underglow" /></p>
<p>Here is a quick demo on Youtube (with NPKC KC60) (<a href="https://www.youtube.com/watch?v=VKrpPAHlisY">https://www.youtube.com/watch?v=VKrpPAHlisY</a>).</p>
<p>For this mod, you need an unused pin wiring to DI of WS2812 strip. After wiring the VCC, GND, and DI, you can enable the underglow in your Makefile.</p>
<pre><code>RGBLIGHT_ENABLE = yes</code></pre>
<p>Please note that the underglow is not compatible with audio output. So you cannot enable both of them at the same time.</p>
<p>Please add the following options into your config.h, and set them up according your hardware configuration. These settings are for the F4 by default:</p>
<pre><code>#define ws2812_PORTREG  PORTF
#define ws2812_DDRREG   DDRF
#define ws2812_pin PF4
#define RGBLED_NUM 14     // Number of LEDs
#define RGBLIGHT_HUE_STEP 10
#define RGBLIGHT_SAT_STEP 17
#define RGBLIGHT_VAL_STEP 17</code></pre>
<p>You'll need to edit <code>PORTF</code>, <code>DDRF</code>, and <code>PF4</code> on the first three lines to the port/pin you have your LED(s) wired to, eg for B3 change things to:</p>
<pre><code>#define ws2812_PORTREG  PORTB
#define ws2812_DDRREG   DDRB
#define ws2812_pin PB3</code></pre>
<p>The firmware supports 5 different light effects, and the color (hue, saturation, brightness) can be customized in most effects. To control the underglow, you need to modify your keymap file to assign those functions to some keys/key combinations. For details, please check this keymap. <code>keyboards/planck/keymaps/yang/keymap.c</code></p>
<h3 id="ws2812-wiring"><a href="#ws2812-wiring">WS2812 Wiring</a></h3>
<p><img src="https://raw.githubusercontent.com/yangliu/qmk_firmware/planck-rgb/keyboards/planck/keymaps/yang/WS2812-wiring.jpg" alt="WS2812 Wiring" /></p>
<p>Please note the USB port can only supply a limited amount of power to the keyboard (500mA by standard, however, modern computer and most usb hubs can provide 700+mA.). According to the data of NeoPixel from Adafruit, 30 WS2812 LEDs require a 5V 1A power supply, LEDs used in this mod should not more than 20.</p>
<h2 id="safety-considerations"><a href="#safety-considerations">Safety Considerations</a></h2>
<p>You probably don't want to &quot;brick&quot; your keyboard, making it impossible<br />to rewrite firmware onto it. Here are some of the parameters to show<br />what things are (and likely aren't) too risky.</p>
<ul>
<li>If a keyboard map does not include RESET, then, to get into DFU<br /> mode, you will need to press the reset button on the PCB, which<br /> requires unscrewing some bits.<br /></li>
<li>Messing with tmk_core / common files might make the keyboard<br /> inoperable<br /></li>
<li>Too large a .hex file is trouble; <code>make dfu</code> will erase the block,<br /> test the size (oops, wrong order!), which errors out, failing to<br /> flash the keyboard<br /></li>
<li>DFU tools do /not/ allow you to write into the bootloader (unless<br /> you throw in extra fruitsalad of options), so there is little risk<br /> there.<br /></li>
<li>EEPROM has around a 100000 write cycle. You shouldn't rewrite the<br /> firmware repeatedly and continually; that'll burn the EEPROM<br /> eventually.</li>
</ul>
            </div>
    </div>
  </div>
  <script src="https://vjs.zencdn.net/5.4.4/video.js"></script>

</body>
</html>
